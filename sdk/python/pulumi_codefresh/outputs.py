# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AccountBuild',
    'AccountLimit',
    'ContextSpec',
    'ContextSpecConfig',
    'ContextSpecSecret',
    'ContextSpecSecretyaml',
    'ContextSpecStorageazuref',
    'ContextSpecStorageazurefData',
    'ContextSpecStorageazurefDataAuth',
    'ContextSpecStoragegc',
    'ContextSpecStoragegcData',
    'ContextSpecStoragegcDataAuth',
    'ContextSpecStorages3',
    'ContextSpecStorages3Data',
    'ContextSpecStorages3DataAuth',
    'ContextSpecYaml',
    'PipelineSpec',
    'PipelineSpecOptions',
    'PipelineSpecRuntimeEnvironment',
    'PipelineSpecSpecTemplate',
    'PipelineSpecTerminationPolicy',
    'PipelineSpecTerminationPolicyOnCreateBranch',
    'PipelineSpecTrigger',
    'PipelineSpecTriggerOption',
    'PipelineSpecTriggerRuntimeEnvironment',
    'RegistrySpec',
    'RegistrySpecAcr',
    'RegistrySpecBintray',
    'RegistrySpecDockerhub',
    'RegistrySpecEcr',
    'RegistrySpecGar',
    'RegistrySpecGcr',
    'RegistrySpecOther',
    'StepTypesVersion',
    'UserLogin',
    'UserPersonal',
    'UserShortProfile',
    'GetCurrentAccountUserResult',
    'GetStepTypesVersionResult',
    'GetUserLoginResult',
    'GetUserLoginCredentialResult',
    'GetUserLoginIdpResult',
    'GetUserPersonalResult',
    'GetUserShortProfileResult',
    'GetUsersUserResult',
    'GetUsersUserLoginResult',
    'GetUsersUserLoginCredentialResult',
    'GetUsersUserLoginIdpResult',
    'GetUsersUserPersonalResult',
    'GetUsersUserShortProfileResult',
]

@pulumi.output_type
class AccountBuild(dict):
    def __init__(__self__, *,
                 parallel: int,
                 nodes: Optional[int] = None):
        """
        :param int parallel: How many pipelines can be run in parallel.
               ` `node` - (Optional) Number of nodes.
        """
        pulumi.set(__self__, "parallel", parallel)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)

    @property
    @pulumi.getter
    def parallel(self) -> int:
        """
        How many pipelines can be run in parallel.
        ` `node` - (Optional) Number of nodes.
        """
        return pulumi.get(self, "parallel")

    @property
    @pulumi.getter
    def nodes(self) -> Optional[int]:
        return pulumi.get(self, "nodes")


@pulumi.output_type
class AccountLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataRetentionWeeks":
            suggest = "data_retention_weeks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collaborators: int,
                 data_retention_weeks: Optional[int] = None):
        """
        :param int collaborators: Max account's collaborators number.
        :param int data_retention_weeks: -(Optional) How long in weeks will the builds be stored.
        """
        pulumi.set(__self__, "collaborators", collaborators)
        if data_retention_weeks is not None:
            pulumi.set(__self__, "data_retention_weeks", data_retention_weeks)

    @property
    @pulumi.getter
    def collaborators(self) -> int:
        """
        Max account's collaborators number.
        """
        return pulumi.get(self, "collaborators")

    @property
    @pulumi.getter(name="dataRetentionWeeks")
    def data_retention_weeks(self) -> Optional[int]:
        """
        -(Optional) How long in weeks will the builds be stored.
        """
        return pulumi.get(self, "data_retention_weeks")


@pulumi.output_type
class ContextSpec(dict):
    def __init__(__self__, *,
                 config: Optional['outputs.ContextSpecConfig'] = None,
                 secret: Optional['outputs.ContextSpecSecret'] = None,
                 secretyaml: Optional['outputs.ContextSpecSecretyaml'] = None,
                 storageazuref: Optional['outputs.ContextSpecStorageazuref'] = None,
                 storagegc: Optional['outputs.ContextSpecStoragegc'] = None,
                 storages3: Optional['outputs.ContextSpecStorages3'] = None,
                 yaml: Optional['outputs.ContextSpecYaml'] = None):
        """
        :param 'ContextSpecConfigArgs' config: A `config` block as documented below. Shared Config [spec](https://codefresh-io.github.io/cli/contexts/spec/config/).
        :param 'ContextSpecSecretArgs' secret: A `secret` block as documented below. Shared Secret [spec](https://codefresh-io.github.io/cli/contexts/spec/secret/).
        :param 'ContextSpecSecretyamlArgs' secretyaml: A `secretyaml` block as documented below. Secret Yaml Configuration Context[spec](https://codefresh-io.github.io/cli/contexts/spec/secret-yaml/).
        :param 'ContextSpecYamlArgs' yaml: A `yaml` block as documented below. Yaml Configuration Context [spec](https://codefresh-io.github.io/cli/contexts/spec/yaml/).
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if secretyaml is not None:
            pulumi.set(__self__, "secretyaml", secretyaml)
        if storageazuref is not None:
            pulumi.set(__self__, "storageazuref", storageazuref)
        if storagegc is not None:
            pulumi.set(__self__, "storagegc", storagegc)
        if storages3 is not None:
            pulumi.set(__self__, "storages3", storages3)
        if yaml is not None:
            pulumi.set(__self__, "yaml", yaml)

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.ContextSpecConfig']:
        """
        A `config` block as documented below. Shared Config [spec](https://codefresh-io.github.io/cli/contexts/spec/config/).
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ContextSpecSecret']:
        """
        A `secret` block as documented below. Shared Secret [spec](https://codefresh-io.github.io/cli/contexts/spec/secret/).
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def secretyaml(self) -> Optional['outputs.ContextSpecSecretyaml']:
        """
        A `secretyaml` block as documented below. Secret Yaml Configuration Context[spec](https://codefresh-io.github.io/cli/contexts/spec/secret-yaml/).
        """
        return pulumi.get(self, "secretyaml")

    @property
    @pulumi.getter
    def storageazuref(self) -> Optional['outputs.ContextSpecStorageazuref']:
        return pulumi.get(self, "storageazuref")

    @property
    @pulumi.getter
    def storagegc(self) -> Optional['outputs.ContextSpecStoragegc']:
        return pulumi.get(self, "storagegc")

    @property
    @pulumi.getter
    def storages3(self) -> Optional['outputs.ContextSpecStorages3']:
        return pulumi.get(self, "storages3")

    @property
    @pulumi.getter
    def yaml(self) -> Optional['outputs.ContextSpecYaml']:
        """
        A `yaml` block as documented below. Yaml Configuration Context [spec](https://codefresh-io.github.io/cli/contexts/spec/yaml/).
        """
        return pulumi.get(self, "yaml")


@pulumi.output_type
class ContextSpecConfig(dict):
    def __init__(__self__, *,
                 data: Mapping[str, str]):
        """
        :param Mapping[str, str] data: Map of strings representing the variables to be defined in the Shared Config.
        """
        pulumi.set(__self__, "data", data)

    @property
    @pulumi.getter
    def data(self) -> Mapping[str, str]:
        """
        Map of strings representing the variables to be defined in the Shared Config.
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class ContextSpecSecret(dict):
    def __init__(__self__, *,
                 data: Mapping[str, str]):
        """
        :param Mapping[str, str] data: Map of strings representing the variables to be defined in the Shared Config.
        """
        pulumi.set(__self__, "data", data)

    @property
    @pulumi.getter
    def data(self) -> Mapping[str, str]:
        """
        Map of strings representing the variables to be defined in the Shared Config.
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class ContextSpecSecretyaml(dict):
    def __init__(__self__, *,
                 data: str):
        """
        :param str data: String representing a YAML file content
        """
        pulumi.set(__self__, "data", data)

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        String representing a YAML file content
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class ContextSpecStorageazuref(dict):
    def __init__(__self__, *,
                 data: 'outputs.ContextSpecStorageazurefData'):
        """
        :param 'ContextSpecStorageazurefDataArgs' data: Map of strings representing the variables to be defined in the Shared Config.
        """
        pulumi.set(__self__, "data", data)

    @property
    @pulumi.getter
    def data(self) -> 'outputs.ContextSpecStorageazurefData':
        """
        Map of strings representing the variables to be defined in the Shared Config.
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class ContextSpecStorageazurefData(dict):
    def __init__(__self__, *,
                 auth: 'outputs.ContextSpecStorageazurefDataAuth'):
        pulumi.set(__self__, "auth", auth)

    @property
    @pulumi.getter
    def auth(self) -> 'outputs.ContextSpecStorageazurefDataAuth':
        return pulumi.get(self, "auth")


@pulumi.output_type
class ContextSpecStorageazurefDataAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountKey":
            suggest = "account_key"
        elif key == "accountName":
            suggest = "account_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContextSpecStorageazurefDataAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContextSpecStorageazurefDataAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContextSpecStorageazurefDataAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_key: str,
                 account_name: str,
                 type: str):
        pulumi.set(__self__, "account_key", account_key)
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> str:
        return pulumi.get(self, "account_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> str:
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class ContextSpecStoragegc(dict):
    def __init__(__self__, *,
                 data: 'outputs.ContextSpecStoragegcData'):
        """
        :param 'ContextSpecStoragegcDataArgs' data: Map of strings representing the variables to be defined in the Shared Config.
        """
        pulumi.set(__self__, "data", data)

    @property
    @pulumi.getter
    def data(self) -> 'outputs.ContextSpecStoragegcData':
        """
        Map of strings representing the variables to be defined in the Shared Config.
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class ContextSpecStoragegcData(dict):
    def __init__(__self__, *,
                 auth: 'outputs.ContextSpecStoragegcDataAuth'):
        pulumi.set(__self__, "auth", auth)

    @property
    @pulumi.getter
    def auth(self) -> 'outputs.ContextSpecStoragegcDataAuth':
        return pulumi.get(self, "auth")


@pulumi.output_type
class ContextSpecStoragegcDataAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonConfig":
            suggest = "json_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContextSpecStoragegcDataAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContextSpecStoragegcDataAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContextSpecStoragegcDataAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 json_config: Mapping[str, Any],
                 type: str):
        pulumi.set(__self__, "json_config", json_config)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="jsonConfig")
    def json_config(self) -> Mapping[str, Any]:
        return pulumi.get(self, "json_config")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class ContextSpecStorages3(dict):
    def __init__(__self__, *,
                 data: 'outputs.ContextSpecStorages3Data'):
        """
        :param 'ContextSpecStorages3DataArgs' data: Map of strings representing the variables to be defined in the Shared Config.
        """
        pulumi.set(__self__, "data", data)

    @property
    @pulumi.getter
    def data(self) -> 'outputs.ContextSpecStorages3Data':
        """
        Map of strings representing the variables to be defined in the Shared Config.
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class ContextSpecStorages3Data(dict):
    def __init__(__self__, *,
                 auth: 'outputs.ContextSpecStorages3DataAuth'):
        pulumi.set(__self__, "auth", auth)

    @property
    @pulumi.getter
    def auth(self) -> 'outputs.ContextSpecStorages3DataAuth':
        return pulumi.get(self, "auth")


@pulumi.output_type
class ContextSpecStorages3DataAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonConfig":
            suggest = "json_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContextSpecStorages3DataAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContextSpecStorages3DataAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContextSpecStorages3DataAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 json_config: Mapping[str, Any],
                 type: str):
        pulumi.set(__self__, "json_config", json_config)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="jsonConfig")
    def json_config(self) -> Mapping[str, Any]:
        return pulumi.get(self, "json_config")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class ContextSpecYaml(dict):
    def __init__(__self__, *,
                 data: str):
        """
        :param str data: String representing a YAML file content
        """
        pulumi.set(__self__, "data", data)

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        String representing a YAML file content
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class PipelineSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "branchConcurrency":
            suggest = "branch_concurrency"
        elif key == "packId":
            suggest = "pack_id"
        elif key == "requiredAvailableStorage":
            suggest = "required_available_storage"
        elif key == "runtimeEnvironments":
            suggest = "runtime_environments"
        elif key == "specTemplates":
            suggest = "spec_templates"
        elif key == "terminationPolicy":
            suggest = "termination_policy"
        elif key == "triggerConcurrency":
            suggest = "trigger_concurrency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch_concurrency: Optional[int] = None,
                 concurrency: Optional[int] = None,
                 contexts: Optional[Sequence[str]] = None,
                 options: Optional['outputs.PipelineSpecOptions'] = None,
                 pack_id: Optional[str] = None,
                 priority: Optional[int] = None,
                 required_available_storage: Optional[str] = None,
                 runtime_environments: Optional[Sequence['outputs.PipelineSpecRuntimeEnvironment']] = None,
                 spec_templates: Optional[Sequence['outputs.PipelineSpecSpecTemplate']] = None,
                 termination_policy: Optional['outputs.PipelineSpecTerminationPolicy'] = None,
                 trigger_concurrency: Optional[int] = None,
                 triggers: Optional[Sequence['outputs.PipelineSpecTrigger']] = None,
                 variables: Optional[Mapping[str, str]] = None):
        """
        :param int branch_concurrency: The maximum amount of concurrent builds that may run for each branch
        :param int concurrency: The maximum amount of concurrent builds.
        :param Sequence[str] contexts: A list of strings representing the contexts ([shared_configuration](https://codefresh.io/docs/docs/configure-ci-cd-pipeline/shared-configuration/)) to be configured for the pipeline
        :param 'PipelineSpecOptionsArgs' options: A `options` block as documented below.
        :param str pack_id: SAAS pack (`5cd1746617313f468d669013` for Small; `5cd1746717313f468d669014` for Medium; `5cd1746817313f468d669015` for Large; `5cd1746817313f468d669017` for XL; `5cd1746817313f468d669018` for XXL)
        :param int priority: Helps to organize the order of builds execution in case of reaching the concurrency limit.
        :param str required_available_storage: Minimum disk space required for build filesystem ( unit Gi is required)
        :param Sequence['PipelineSpecRuntimeEnvironmentArgs'] runtime_environments: A collection of `runtime_environment` blocks as documented below.
        :param Sequence['PipelineSpecSpecTemplateArgs'] spec_templates: A collection of `spec_template` blocks as documented below.
        :param 'PipelineSpecTerminationPolicyArgs' termination_policy: A `termination_policy` block as documented below.
        :param int trigger_concurrency: The maximum amount of concurrent builds that may run for each trigger.
        :param Sequence['PipelineSpecTriggerArgs'] triggers: A collection of `trigger` blocks as documented below. Triggers [documentation](https://codefresh.io/docs/docs/configure-ci-cd-pipeline/triggers/git-triggers/).
        :param Mapping[str, str] variables: Pipeline variables.
        """
        if branch_concurrency is not None:
            pulumi.set(__self__, "branch_concurrency", branch_concurrency)
        if concurrency is not None:
            pulumi.set(__self__, "concurrency", concurrency)
        if contexts is not None:
            pulumi.set(__self__, "contexts", contexts)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if pack_id is not None:
            pulumi.set(__self__, "pack_id", pack_id)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if required_available_storage is not None:
            pulumi.set(__self__, "required_available_storage", required_available_storage)
        if runtime_environments is not None:
            pulumi.set(__self__, "runtime_environments", runtime_environments)
        if spec_templates is not None:
            pulumi.set(__self__, "spec_templates", spec_templates)
        if termination_policy is not None:
            pulumi.set(__self__, "termination_policy", termination_policy)
        if trigger_concurrency is not None:
            pulumi.set(__self__, "trigger_concurrency", trigger_concurrency)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter(name="branchConcurrency")
    def branch_concurrency(self) -> Optional[int]:
        """
        The maximum amount of concurrent builds that may run for each branch
        """
        return pulumi.get(self, "branch_concurrency")

    @property
    @pulumi.getter
    def concurrency(self) -> Optional[int]:
        """
        The maximum amount of concurrent builds.
        """
        return pulumi.get(self, "concurrency")

    @property
    @pulumi.getter
    def contexts(self) -> Optional[Sequence[str]]:
        """
        A list of strings representing the contexts ([shared_configuration](https://codefresh.io/docs/docs/configure-ci-cd-pipeline/shared-configuration/)) to be configured for the pipeline
        """
        return pulumi.get(self, "contexts")

    @property
    @pulumi.getter
    def options(self) -> Optional['outputs.PipelineSpecOptions']:
        """
        A `options` block as documented below.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="packId")
    def pack_id(self) -> Optional[str]:
        """
        SAAS pack (`5cd1746617313f468d669013` for Small; `5cd1746717313f468d669014` for Medium; `5cd1746817313f468d669015` for Large; `5cd1746817313f468d669017` for XL; `5cd1746817313f468d669018` for XXL)
        """
        return pulumi.get(self, "pack_id")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Helps to organize the order of builds execution in case of reaching the concurrency limit.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="requiredAvailableStorage")
    def required_available_storage(self) -> Optional[str]:
        """
        Minimum disk space required for build filesystem ( unit Gi is required)
        """
        return pulumi.get(self, "required_available_storage")

    @property
    @pulumi.getter(name="runtimeEnvironments")
    def runtime_environments(self) -> Optional[Sequence['outputs.PipelineSpecRuntimeEnvironment']]:
        """
        A collection of `runtime_environment` blocks as documented below.
        """
        return pulumi.get(self, "runtime_environments")

    @property
    @pulumi.getter(name="specTemplates")
    def spec_templates(self) -> Optional[Sequence['outputs.PipelineSpecSpecTemplate']]:
        """
        A collection of `spec_template` blocks as documented below.
        """
        return pulumi.get(self, "spec_templates")

    @property
    @pulumi.getter(name="terminationPolicy")
    def termination_policy(self) -> Optional['outputs.PipelineSpecTerminationPolicy']:
        """
        A `termination_policy` block as documented below.
        """
        return pulumi.get(self, "termination_policy")

    @property
    @pulumi.getter(name="triggerConcurrency")
    def trigger_concurrency(self) -> Optional[int]:
        """
        The maximum amount of concurrent builds that may run for each trigger.
        """
        return pulumi.get(self, "trigger_concurrency")

    @property
    @pulumi.getter
    def triggers(self) -> Optional[Sequence['outputs.PipelineSpecTrigger']]:
        """
        A collection of `trigger` blocks as documented below. Triggers [documentation](https://codefresh.io/docs/docs/configure-ci-cd-pipeline/triggers/git-triggers/).
        """
        return pulumi.get(self, "triggers")

    @property
    @pulumi.getter
    def variables(self) -> Optional[Mapping[str, str]]:
        """
        Pipeline variables.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class PipelineSpecOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepPvcsForPendingApproval":
            suggest = "keep_pvcs_for_pending_approval"
        elif key == "pendingApprovalConcurrencyApplied":
            suggest = "pending_approval_concurrency_applied"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineSpecOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineSpecOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineSpecOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 keep_pvcs_for_pending_approval: Optional[bool] = None,
                 pending_approval_concurrency_applied: Optional[bool] = None):
        """
        :param bool keep_pvcs_for_pending_approval: Boolean for the Settings under pending approval: `When build enters "Pending Approval" state, volume should`:
               * Default (attribute not specified): "Use Setting accounts"
               * true: "Remain (build remains active)"
               * false: "Be removed"
        :param bool pending_approval_concurrency_applied: Boolean for the Settings under pending approval: `Pipeline concurrency policy: Builds on "Pending Approval" state should be`:
               * Default (attribute not specified): "Use Setting accounts"
               * true: "Included in concurrency"
               * false: "Not included in concurrency"
        """
        if keep_pvcs_for_pending_approval is not None:
            pulumi.set(__self__, "keep_pvcs_for_pending_approval", keep_pvcs_for_pending_approval)
        if pending_approval_concurrency_applied is not None:
            pulumi.set(__self__, "pending_approval_concurrency_applied", pending_approval_concurrency_applied)

    @property
    @pulumi.getter(name="keepPvcsForPendingApproval")
    def keep_pvcs_for_pending_approval(self) -> Optional[bool]:
        """
        Boolean for the Settings under pending approval: `When build enters "Pending Approval" state, volume should`:
        * Default (attribute not specified): "Use Setting accounts"
        * true: "Remain (build remains active)"
        * false: "Be removed"
        """
        return pulumi.get(self, "keep_pvcs_for_pending_approval")

    @property
    @pulumi.getter(name="pendingApprovalConcurrencyApplied")
    def pending_approval_concurrency_applied(self) -> Optional[bool]:
        """
        Boolean for the Settings under pending approval: `Pipeline concurrency policy: Builds on "Pending Approval" state should be`:
        * Default (attribute not specified): "Use Setting accounts"
        * true: "Included in concurrency"
        * false: "Not included in concurrency"
        """
        return pulumi.get(self, "pending_approval_concurrency_applied")


@pulumi.output_type
class PipelineSpecRuntimeEnvironment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dindStorage":
            suggest = "dind_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineSpecRuntimeEnvironment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineSpecRuntimeEnvironment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineSpecRuntimeEnvironment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu: Optional[str] = None,
                 dind_storage: Optional[str] = None,
                 memory: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str cpu: A required amount of CPU.
        :param str dind_storage: A pipeline shared storage.
        :param str memory: A required amount of memory.
        :param str name: A name of runtime.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if dind_storage is not None:
            pulumi.set(__self__, "dind_storage", dind_storage)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[str]:
        """
        A required amount of CPU.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter(name="dindStorage")
    def dind_storage(self) -> Optional[str]:
        """
        A pipeline shared storage.
        """
        return pulumi.get(self, "dind_storage")

    @property
    @pulumi.getter
    def memory(self) -> Optional[str]:
        """
        A required amount of memory.
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A name of runtime.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PipelineSpecSpecTemplate(dict):
    def __init__(__self__, *,
                 path: str,
                 repo: str,
                 revision: str,
                 context: Optional[str] = None,
                 location: Optional[str] = None):
        """
        :param str path: The relative path to the Codefresh pipeline file.
        :param str repo: The GitHub `account/repo_name`.
        :param str revision: The pipeline's revision. Should be added to the **lifecycle/ignore_changes** or incremented mannually each update.
        :param str context: The Codefresh Git [context](https://codefresh.io/docs/docs/integrations/git-providers/).
        :param str location: Default value - **git**.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "repo", repo)
        pulumi.set(__self__, "revision", revision)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if location is not None:
            pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The relative path to the Codefresh pipeline file.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def repo(self) -> str:
        """
        The GitHub `account/repo_name`.
        """
        return pulumi.get(self, "repo")

    @property
    @pulumi.getter
    def revision(self) -> str:
        """
        The pipeline's revision. Should be added to the **lifecycle/ignore_changes** or incremented mannually each update.
        """
        return pulumi.get(self, "revision")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        The Codefresh Git [context](https://codefresh.io/docs/docs/integrations/git-providers/).
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Default value - **git**.
        """
        return pulumi.get(self, "location")


@pulumi.output_type
class PipelineSpecTerminationPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onCreateBranch":
            suggest = "on_create_branch"
        elif key == "onTerminateAnnotation":
            suggest = "on_terminate_annotation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineSpecTerminationPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineSpecTerminationPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineSpecTerminationPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_create_branch: Optional['outputs.PipelineSpecTerminationPolicyOnCreateBranch'] = None,
                 on_terminate_annotation: Optional[bool] = None):
        """
        :param 'PipelineSpecTerminationPolicyOnCreateBranchArgs' on_create_branch: A `on_create_branch` block as documented below.
        :param bool on_terminate_annotation: Boolean. Enables the policy `Once a build is terminated, terminate all child builds initiated from it`. Default false.
        """
        if on_create_branch is not None:
            pulumi.set(__self__, "on_create_branch", on_create_branch)
        if on_terminate_annotation is not None:
            pulumi.set(__self__, "on_terminate_annotation", on_terminate_annotation)

    @property
    @pulumi.getter(name="onCreateBranch")
    def on_create_branch(self) -> Optional['outputs.PipelineSpecTerminationPolicyOnCreateBranch']:
        """
        A `on_create_branch` block as documented below.
        """
        return pulumi.get(self, "on_create_branch")

    @property
    @pulumi.getter(name="onTerminateAnnotation")
    def on_terminate_annotation(self) -> Optional[bool]:
        """
        Boolean. Enables the policy `Once a build is terminated, terminate all child builds initiated from it`. Default false.
        """
        return pulumi.get(self, "on_terminate_annotation")


@pulumi.output_type
class PipelineSpecTerminationPolicyOnCreateBranch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "branchName":
            suggest = "branch_name"
        elif key == "ignoreBranch":
            suggest = "ignore_branch"
        elif key == "ignoreTrigger":
            suggest = "ignore_trigger"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineSpecTerminationPolicyOnCreateBranch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineSpecTerminationPolicyOnCreateBranch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineSpecTerminationPolicyOnCreateBranch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch_name: Optional[str] = None,
                 ignore_branch: Optional[bool] = None,
                 ignore_trigger: Optional[bool] = None):
        """
        :param str branch_name: A regular expression to filter the branches on with the termination policy applies.
        :param bool ignore_branch: Boolean. See table below for usage.
        :param bool ignore_trigger: Boolean. See table below for usage.
        """
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if ignore_branch is not None:
            pulumi.set(__self__, "ignore_branch", ignore_branch)
        if ignore_trigger is not None:
            pulumi.set(__self__, "ignore_trigger", ignore_trigger)

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[str]:
        """
        A regular expression to filter the branches on with the termination policy applies.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="ignoreBranch")
    def ignore_branch(self) -> Optional[bool]:
        """
        Boolean. See table below for usage.
        """
        return pulumi.get(self, "ignore_branch")

    @property
    @pulumi.getter(name="ignoreTrigger")
    def ignore_trigger(self) -> Optional[bool]:
        """
        Boolean. See table below for usage.
        """
        return pulumi.get(self, "ignore_trigger")


@pulumi.output_type
class PipelineSpecTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "branchRegex":
            suggest = "branch_regex"
        elif key == "branchRegexInput":
            suggest = "branch_regex_input"
        elif key == "commentRegex":
            suggest = "comment_regex"
        elif key == "commitStatusTitle":
            suggest = "commit_status_title"
        elif key == "modifiedFilesGlob":
            suggest = "modified_files_glob"
        elif key == "pullRequestAllowForkEvents":
            suggest = "pull_request_allow_fork_events"
        elif key == "pullRequestTargetBranchRegex":
            suggest = "pull_request_target_branch_regex"
        elif key == "runtimeEnvironments":
            suggest = "runtime_environments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineSpecTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineSpecTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineSpecTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch_regex: Optional[str] = None,
                 branch_regex_input: Optional[str] = None,
                 comment_regex: Optional[str] = None,
                 commit_status_title: Optional[str] = None,
                 context: Optional[str] = None,
                 contexts: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 disabled: Optional[bool] = None,
                 events: Optional[Sequence[str]] = None,
                 modified_files_glob: Optional[str] = None,
                 name: Optional[str] = None,
                 options: Optional[Sequence['outputs.PipelineSpecTriggerOption']] = None,
                 provider: Optional[str] = None,
                 pull_request_allow_fork_events: Optional[bool] = None,
                 pull_request_target_branch_regex: Optional[str] = None,
                 repo: Optional[str] = None,
                 runtime_environments: Optional[Sequence['outputs.PipelineSpecTriggerRuntimeEnvironment']] = None,
                 type: Optional[str] = None,
                 variables: Optional[Mapping[str, str]] = None):
        """
        :param str branch_regex: A regular expression and will only trigger for branches that match this naming pattern.
        :param str branch_regex_input: Flag to manage how the `branch_regex` field is interpreted. Possible values: "multiselect-exclude", "multiselect", "regex". Default: "regex"
        :param str comment_regex: A regular expression and will only trigger for pull requests where a comment matches this naming pattern.
        :param str commit_status_title: The commit status title pushed to the GIT version control system.
        :param str context: Codefresh Git context.
        :param Sequence[str] contexts: A list of strings representing the contexts ([shared_configuration](https://codefresh.io/docs/docs/configure-ci-cd-pipeline/shared-configuration/)) to be loaded when the trigger is executed
        :param str description: The trigger description.
        :param bool disabled: Boolean. If true, trigger will never be activated.
        :param Sequence[str] events: A list of GitHub events for which a Pipeline is triggered. Default value - **push.heads**.
        :param str modified_files_glob: Allows to constrain the build and trigger it only if the modified files from the commit match this glob expression.
        :param str name: The display name for the pipeline.
        :param Sequence['PipelineSpecTriggerOptionArgs'] options: A `options` block as documented below.
        :param str provider: Default value - **github**.
        :param bool pull_request_allow_fork_events: Boolean. If this trigger is also applicable to Git forks.
        :param str pull_request_target_branch_regex: A regular expression and will only trigger for pull requests to branches that match this naming pattern.
        :param str repo: The GitHub `account/repo_name`.
        :param Sequence['PipelineSpecTriggerRuntimeEnvironmentArgs'] runtime_environments: A collection of `runtime_environment` blocks as documented below.
               - `options`: (Optional) A collection `option` blocks as documented below.
               ---
        :param str type: The trigger type. Default value - **git**.
        :param Mapping[str, str] variables: Trigger variables.
        """
        if branch_regex is not None:
            pulumi.set(__self__, "branch_regex", branch_regex)
        if branch_regex_input is not None:
            pulumi.set(__self__, "branch_regex_input", branch_regex_input)
        if comment_regex is not None:
            pulumi.set(__self__, "comment_regex", comment_regex)
        if commit_status_title is not None:
            pulumi.set(__self__, "commit_status_title", commit_status_title)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if contexts is not None:
            pulumi.set(__self__, "contexts", contexts)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if modified_files_glob is not None:
            pulumi.set(__self__, "modified_files_glob", modified_files_glob)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if pull_request_allow_fork_events is not None:
            pulumi.set(__self__, "pull_request_allow_fork_events", pull_request_allow_fork_events)
        if pull_request_target_branch_regex is not None:
            pulumi.set(__self__, "pull_request_target_branch_regex", pull_request_target_branch_regex)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)
        if runtime_environments is not None:
            pulumi.set(__self__, "runtime_environments", runtime_environments)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter(name="branchRegex")
    def branch_regex(self) -> Optional[str]:
        """
        A regular expression and will only trigger for branches that match this naming pattern.
        """
        return pulumi.get(self, "branch_regex")

    @property
    @pulumi.getter(name="branchRegexInput")
    def branch_regex_input(self) -> Optional[str]:
        """
        Flag to manage how the `branch_regex` field is interpreted. Possible values: "multiselect-exclude", "multiselect", "regex". Default: "regex"
        """
        return pulumi.get(self, "branch_regex_input")

    @property
    @pulumi.getter(name="commentRegex")
    def comment_regex(self) -> Optional[str]:
        """
        A regular expression and will only trigger for pull requests where a comment matches this naming pattern.
        """
        return pulumi.get(self, "comment_regex")

    @property
    @pulumi.getter(name="commitStatusTitle")
    def commit_status_title(self) -> Optional[str]:
        """
        The commit status title pushed to the GIT version control system.
        """
        return pulumi.get(self, "commit_status_title")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        Codefresh Git context.
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def contexts(self) -> Optional[Sequence[str]]:
        """
        A list of strings representing the contexts ([shared_configuration](https://codefresh.io/docs/docs/configure-ci-cd-pipeline/shared-configuration/)) to be loaded when the trigger is executed
        """
        return pulumi.get(self, "contexts")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The trigger description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        Boolean. If true, trigger will never be activated.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence[str]]:
        """
        A list of GitHub events for which a Pipeline is triggered. Default value - **push.heads**.
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="modifiedFilesGlob")
    def modified_files_glob(self) -> Optional[str]:
        """
        Allows to constrain the build and trigger it only if the modified files from the commit match this glob expression.
        """
        return pulumi.get(self, "modified_files_glob")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The display name for the pipeline.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def options(self) -> Optional[Sequence['outputs.PipelineSpecTriggerOption']]:
        """
        A `options` block as documented below.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        Default value - **github**.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="pullRequestAllowForkEvents")
    def pull_request_allow_fork_events(self) -> Optional[bool]:
        """
        Boolean. If this trigger is also applicable to Git forks.
        """
        return pulumi.get(self, "pull_request_allow_fork_events")

    @property
    @pulumi.getter(name="pullRequestTargetBranchRegex")
    def pull_request_target_branch_regex(self) -> Optional[str]:
        """
        A regular expression and will only trigger for pull requests to branches that match this naming pattern.
        """
        return pulumi.get(self, "pull_request_target_branch_regex")

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        """
        The GitHub `account/repo_name`.
        """
        return pulumi.get(self, "repo")

    @property
    @pulumi.getter(name="runtimeEnvironments")
    def runtime_environments(self) -> Optional[Sequence['outputs.PipelineSpecTriggerRuntimeEnvironment']]:
        """
        A collection of `runtime_environment` blocks as documented below.
        - `options`: (Optional) A collection `option` blocks as documented below.
        ---
        """
        return pulumi.get(self, "runtime_environments")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The trigger type. Default value - **git**.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def variables(self) -> Optional[Mapping[str, str]]:
        """
        Trigger variables.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class PipelineSpecTriggerOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableNotifications":
            suggest = "enable_notifications"
        elif key == "noCache":
            suggest = "no_cache"
        elif key == "noCfCache":
            suggest = "no_cf_cache"
        elif key == "resetVolume":
            suggest = "reset_volume"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineSpecTriggerOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineSpecTriggerOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineSpecTriggerOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_notifications: Optional[bool] = None,
                 no_cache: Optional[bool] = None,
                 no_cf_cache: Optional[bool] = None,
                 reset_volume: Optional[bool] = None):
        """
        :param bool enable_notifications: Boolean. If false the pipeline will not send notifications to Slack and status updates back to the Git provider. Default false
        :param bool no_cache: Boolean. If true, docker layer cache is disabled. Default false
        :param bool no_cf_cache: Boolean. If true, extra Codefresh caching is disabled. Default false
        :param bool reset_volume: Boolean. If true, all files on volume will be deleted before each execution. Default false
        """
        if enable_notifications is not None:
            pulumi.set(__self__, "enable_notifications", enable_notifications)
        if no_cache is not None:
            pulumi.set(__self__, "no_cache", no_cache)
        if no_cf_cache is not None:
            pulumi.set(__self__, "no_cf_cache", no_cf_cache)
        if reset_volume is not None:
            pulumi.set(__self__, "reset_volume", reset_volume)

    @property
    @pulumi.getter(name="enableNotifications")
    def enable_notifications(self) -> Optional[bool]:
        """
        Boolean. If false the pipeline will not send notifications to Slack and status updates back to the Git provider. Default false
        """
        return pulumi.get(self, "enable_notifications")

    @property
    @pulumi.getter(name="noCache")
    def no_cache(self) -> Optional[bool]:
        """
        Boolean. If true, docker layer cache is disabled. Default false
        """
        return pulumi.get(self, "no_cache")

    @property
    @pulumi.getter(name="noCfCache")
    def no_cf_cache(self) -> Optional[bool]:
        """
        Boolean. If true, extra Codefresh caching is disabled. Default false
        """
        return pulumi.get(self, "no_cf_cache")

    @property
    @pulumi.getter(name="resetVolume")
    def reset_volume(self) -> Optional[bool]:
        """
        Boolean. If true, all files on volume will be deleted before each execution. Default false
        """
        return pulumi.get(self, "reset_volume")


@pulumi.output_type
class PipelineSpecTriggerRuntimeEnvironment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dindStorage":
            suggest = "dind_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineSpecTriggerRuntimeEnvironment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineSpecTriggerRuntimeEnvironment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineSpecTriggerRuntimeEnvironment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu: Optional[str] = None,
                 dind_storage: Optional[str] = None,
                 memory: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str cpu: A required amount of CPU.
        :param str dind_storage: A pipeline shared storage.
        :param str memory: A required amount of memory.
        :param str name: A name of runtime.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if dind_storage is not None:
            pulumi.set(__self__, "dind_storage", dind_storage)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[str]:
        """
        A required amount of CPU.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter(name="dindStorage")
    def dind_storage(self) -> Optional[str]:
        """
        A pipeline shared storage.
        """
        return pulumi.get(self, "dind_storage")

    @property
    @pulumi.getter
    def memory(self) -> Optional[str]:
        """
        A required amount of memory.
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A name of runtime.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RegistrySpec(dict):
    def __init__(__self__, *,
                 acr: Optional['outputs.RegistrySpecAcr'] = None,
                 bintray: Optional['outputs.RegistrySpecBintray'] = None,
                 dockerhub: Optional['outputs.RegistrySpecDockerhub'] = None,
                 ecr: Optional['outputs.RegistrySpecEcr'] = None,
                 gar: Optional['outputs.RegistrySpecGar'] = None,
                 gcr: Optional['outputs.RegistrySpecGcr'] = None,
                 other: Optional['outputs.RegistrySpecOther'] = None):
        if acr is not None:
            pulumi.set(__self__, "acr", acr)
        if bintray is not None:
            pulumi.set(__self__, "bintray", bintray)
        if dockerhub is not None:
            pulumi.set(__self__, "dockerhub", dockerhub)
        if ecr is not None:
            pulumi.set(__self__, "ecr", ecr)
        if gar is not None:
            pulumi.set(__self__, "gar", gar)
        if gcr is not None:
            pulumi.set(__self__, "gcr", gcr)
        if other is not None:
            pulumi.set(__self__, "other", other)

    @property
    @pulumi.getter
    def acr(self) -> Optional['outputs.RegistrySpecAcr']:
        return pulumi.get(self, "acr")

    @property
    @pulumi.getter
    def bintray(self) -> Optional['outputs.RegistrySpecBintray']:
        return pulumi.get(self, "bintray")

    @property
    @pulumi.getter
    def dockerhub(self) -> Optional['outputs.RegistrySpecDockerhub']:
        return pulumi.get(self, "dockerhub")

    @property
    @pulumi.getter
    def ecr(self) -> Optional['outputs.RegistrySpecEcr']:
        return pulumi.get(self, "ecr")

    @property
    @pulumi.getter
    def gar(self) -> Optional['outputs.RegistrySpecGar']:
        return pulumi.get(self, "gar")

    @property
    @pulumi.getter
    def gcr(self) -> Optional['outputs.RegistrySpecGcr']:
        return pulumi.get(self, "gcr")

    @property
    @pulumi.getter
    def other(self) -> Optional['outputs.RegistrySpecOther']:
        return pulumi.get(self, "other")


@pulumi.output_type
class RegistrySpecAcr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "repositoryPrefix":
            suggest = "repository_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistrySpecAcr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistrySpecAcr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistrySpecAcr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 domain: str,
                 repository_prefix: Optional[str] = None):
        """
        :param str client_id: _(Required)_ String representing client id.
        :param str client_secret: _(Required)_ String representing client secret.
        :param str domain: _(Required)_ String representing your acr registry domain.
        :param str repository_prefix: _(Optional)_ String. See the [docs](https://codefresh.io/docs/docs/integrations/docker-registries/#using-an-optional-repository-prefix).
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "domain", domain)
        if repository_prefix is not None:
            pulumi.set(__self__, "repository_prefix", repository_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        _(Required)_ String representing client id.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        _(Required)_ String representing client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        _(Required)_ String representing your acr registry domain.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="repositoryPrefix")
    def repository_prefix(self) -> Optional[str]:
        """
        _(Optional)_ String. See the [docs](https://codefresh.io/docs/docs/integrations/docker-registries/#using-an-optional-repository-prefix).
        """
        return pulumi.get(self, "repository_prefix")


@pulumi.output_type
class RegistrySpecBintray(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repositoryPrefix":
            suggest = "repository_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistrySpecBintray. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistrySpecBintray.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistrySpecBintray.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: str,
                 token: str,
                 username: str,
                 repository_prefix: Optional[str] = None):
        """
        :param str domain: _(Required)_ String representing the bintray domain
        :param str token: _(Required)_ String representing token
        :param str username: _(Required)_ String representing the username
        :param str repository_prefix: _(Optional)_ String. See the [docs](https://codefresh.io/docs/docs/integrations/docker-registries/#using-an-optional-repository-prefix).
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "username", username)
        if repository_prefix is not None:
            pulumi.set(__self__, "repository_prefix", repository_prefix)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        _(Required)_ String representing the bintray domain
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        _(Required)_ String representing token
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        _(Required)_ String representing the username
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="repositoryPrefix")
    def repository_prefix(self) -> Optional[str]:
        """
        _(Optional)_ String. See the [docs](https://codefresh.io/docs/docs/integrations/docker-registries/#using-an-optional-repository-prefix).
        """
        return pulumi.get(self, "repository_prefix")


@pulumi.output_type
class RegistrySpecDockerhub(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: _(Required, Sensitive)_ String.
        :param str username: _(Required)_ String.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        _(Required, Sensitive)_ String.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        _(Required)_ String.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class RegistrySpecEcr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "repositoryPrefix":
            suggest = "repository_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistrySpecEcr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistrySpecEcr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistrySpecEcr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: str,
                 region: str,
                 secret_access_key: str,
                 repository_prefix: Optional[str] = None):
        """
        :param str access_key_id: _(Required)_ String representing access key id
        :param str region: _(Required)_ String representing one of the Amazon regions
        :param str secret_access_key: _(Required)_ String representing secret access key
        :param str repository_prefix: _(Optional)_ String. See the [docs](https://codefresh.io/docs/docs/integrations/docker-registries/#using-an-optional-repository-prefix).
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if repository_prefix is not None:
            pulumi.set(__self__, "repository_prefix", repository_prefix)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> str:
        """
        _(Required)_ String representing access key id
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        _(Required)_ String representing one of the Amazon regions
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> str:
        """
        _(Required)_ String representing secret access key
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="repositoryPrefix")
    def repository_prefix(self) -> Optional[str]:
        """
        _(Optional)_ String. See the [docs](https://codefresh.io/docs/docs/integrations/docker-registries/#using-an-optional-repository-prefix).
        """
        return pulumi.get(self, "repository_prefix")


@pulumi.output_type
class RegistrySpecGar(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repositoryPrefix":
            suggest = "repository_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistrySpecGar. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistrySpecGar.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistrySpecGar.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 keyfile: str,
                 location: str,
                 repository_prefix: Optional[str] = None):
        """
        :param str keyfile: _(Required)_ String representing service account json file contents
        :param str location: _(Required)_ String representing one of the Google's gar locations
        :param str repository_prefix: _(Optional)_ String. See the [docs](https://codefresh.io/docs/docs/integrations/docker-registries/#using-an-optional-repository-prefix).
        """
        pulumi.set(__self__, "keyfile", keyfile)
        pulumi.set(__self__, "location", location)
        if repository_prefix is not None:
            pulumi.set(__self__, "repository_prefix", repository_prefix)

    @property
    @pulumi.getter
    def keyfile(self) -> str:
        """
        _(Required)_ String representing service account json file contents
        """
        return pulumi.get(self, "keyfile")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        _(Required)_ String representing one of the Google's gar locations
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="repositoryPrefix")
    def repository_prefix(self) -> Optional[str]:
        """
        _(Optional)_ String. See the [docs](https://codefresh.io/docs/docs/integrations/docker-registries/#using-an-optional-repository-prefix).
        """
        return pulumi.get(self, "repository_prefix")


@pulumi.output_type
class RegistrySpecGcr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repositoryPrefix":
            suggest = "repository_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistrySpecGcr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistrySpecGcr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistrySpecGcr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: str,
                 keyfile: str,
                 repository_prefix: Optional[str] = None):
        """
        :param str domain: _(Required)_ String representing one of the Google's gcr domains
        :param str keyfile: _(Required)_ String representing service account json file contents
        :param str repository_prefix: _(Optional)_ String. See the [docs](https://codefresh.io/docs/docs/integrations/docker-registries/#using-an-optional-repository-prefix).
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "keyfile", keyfile)
        if repository_prefix is not None:
            pulumi.set(__self__, "repository_prefix", repository_prefix)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        _(Required)_ String representing one of the Google's gcr domains
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def keyfile(self) -> str:
        """
        _(Required)_ String representing service account json file contents
        """
        return pulumi.get(self, "keyfile")

    @property
    @pulumi.getter(name="repositoryPrefix")
    def repository_prefix(self) -> Optional[str]:
        """
        _(Optional)_ String. See the [docs](https://codefresh.io/docs/docs/integrations/docker-registries/#using-an-optional-repository-prefix).
        """
        return pulumi.get(self, "repository_prefix")


@pulumi.output_type
class RegistrySpecOther(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "behindFirewall":
            suggest = "behind_firewall"
        elif key == "repositoryPrefix":
            suggest = "repository_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistrySpecOther. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistrySpecOther.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistrySpecOther.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: str,
                 password: str,
                 username: str,
                 behind_firewall: Optional[bool] = None,
                 repository_prefix: Optional[str] = None):
        """
        :param str domain: _(Required)_ String representing the bintray domain
        :param str password: _(Required)_ String representing token
        :param str username: _(Required)_ String representing the username
        :param bool behind_firewall: _(Optional, Default = false)_ Bool. See the [docs](https://codefresh.io/docs/docs/administration/behind-the-firewall/#accessing-an-internal-docker-registry).
        :param str repository_prefix: _(Optional)_ String. See the [docs](https://codefresh.io/docs/docs/integrations/docker-registries/#using-an-optional-repository-prefix).
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if behind_firewall is not None:
            pulumi.set(__self__, "behind_firewall", behind_firewall)
        if repository_prefix is not None:
            pulumi.set(__self__, "repository_prefix", repository_prefix)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        _(Required)_ String representing the bintray domain
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        _(Required)_ String representing token
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        _(Required)_ String representing the username
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="behindFirewall")
    def behind_firewall(self) -> Optional[bool]:
        """
        _(Optional, Default = false)_ Bool. See the [docs](https://codefresh.io/docs/docs/administration/behind-the-firewall/#accessing-an-internal-docker-registry).
        """
        return pulumi.get(self, "behind_firewall")

    @property
    @pulumi.getter(name="repositoryPrefix")
    def repository_prefix(self) -> Optional[str]:
        """
        _(Optional)_ String. See the [docs](https://codefresh.io/docs/docs/integrations/docker-registries/#using-an-optional-repository-prefix).
        """
        return pulumi.get(self, "repository_prefix")


@pulumi.output_type
class StepTypesVersion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stepTypesYaml":
            suggest = "step_types_yaml"
        elif key == "versionNumber":
            suggest = "version_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StepTypesVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StepTypesVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StepTypesVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 step_types_yaml: str,
                 version_number: str):
        """
        :param str step_types_yaml: YAML String containing a valid definition of a typed plugin
        :param str version_number: String representing the semVer for the step
        """
        pulumi.set(__self__, "step_types_yaml", step_types_yaml)
        pulumi.set(__self__, "version_number", version_number)

    @property
    @pulumi.getter(name="stepTypesYaml")
    def step_types_yaml(self) -> str:
        """
        YAML String containing a valid definition of a typed plugin
        """
        return pulumi.get(self, "step_types_yaml")

    @property
    @pulumi.getter(name="versionNumber")
    def version_number(self) -> str:
        """
        String representing the semVer for the step
        """
        return pulumi.get(self, "version_number")


@pulumi.output_type
class UserLogin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idpId":
            suggest = "idp_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserLogin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserLogin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserLogin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 idp_id: Optional[str] = None,
                 sso: Optional[bool] = None):
        """
        :param str idp_id: The id of IDP to the user to.
        """
        if idp_id is not None:
            pulumi.set(__self__, "idp_id", idp_id)
        if sso is not None:
            pulumi.set(__self__, "sso", sso)

    @property
    @pulumi.getter(name="idpId")
    def idp_id(self) -> Optional[str]:
        """
        The id of IDP to the user to.
        """
        return pulumi.get(self, "idp_id")

    @property
    @pulumi.getter
    def sso(self) -> Optional[bool]:
        return pulumi.get(self, "sso")


@pulumi.output_type
class UserPersonal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "companyName":
            suggest = "company_name"
        elif key == "firstName":
            suggest = "first_name"
        elif key == "lastName":
            suggest = "last_name"
        elif key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPersonal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPersonal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPersonal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 company_name: Optional[str] = None,
                 country: Optional[str] = None,
                 first_name: Optional[str] = None,
                 last_name: Optional[str] = None,
                 phone_number: Optional[str] = None):
        """
        :param str company_name: .
        :param str country: .
        :param str first_name: .
        :param str last_name: .
        :param str phone_number: .
        """
        if company_name is not None:
            pulumi.set(__self__, "company_name", company_name)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="companyName")
    def company_name(self) -> Optional[str]:
        """
        .
        """
        return pulumi.get(self, "company_name")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        """
        .
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[str]:
        """
        .
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[str]:
        """
        .
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[str]:
        """
        .
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class UserShortProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserShortProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserShortProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserShortProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_name: Optional[str] = None):
        """
        :param str user_name: The new user name.
        """
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        The new user name.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetCurrentAccountUserResult(dict):
    def __init__(__self__, *,
                 email: str,
                 id: str,
                 name: str):
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> str:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetStepTypesVersionResult(dict):
    def __init__(__self__, *,
                 step_types_yaml: str,
                 version_number: str):
        """
        :param str step_types_yaml: YAML String containing the definition of a typed plugin
        :param str version_number: String representing the semVer for the step
        """
        pulumi.set(__self__, "step_types_yaml", step_types_yaml)
        pulumi.set(__self__, "version_number", version_number)

    @property
    @pulumi.getter(name="stepTypesYaml")
    def step_types_yaml(self) -> str:
        """
        YAML String containing the definition of a typed plugin
        """
        return pulumi.get(self, "step_types_yaml")

    @property
    @pulumi.getter(name="versionNumber")
    def version_number(self) -> str:
        """
        String representing the semVer for the step
        """
        return pulumi.get(self, "version_number")


@pulumi.output_type
class GetUserLoginResult(dict):
    def __init__(__self__, *,
                 credentials: Optional[Sequence['outputs.GetUserLoginCredentialResult']] = None,
                 idps: Optional[Sequence['outputs.GetUserLoginIdpResult']] = None):
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if idps is not None:
            pulumi.set(__self__, "idps", idps)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[Sequence['outputs.GetUserLoginCredentialResult']]:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def idps(self) -> Optional[Sequence['outputs.GetUserLoginIdpResult']]:
        return pulumi.get(self, "idps")


@pulumi.output_type
class GetUserLoginCredentialResult(dict):
    def __init__(__self__, *,
                 permissions: Optional[Sequence[str]] = None):
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetUserLoginIdpResult(dict):
    def __init__(__self__, *,
                 client_type: Optional[str] = None,
                 id: Optional[str] = None):
        if client_type is not None:
            pulumi.set(__self__, "client_type", client_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="clientType")
    def client_type(self) -> Optional[str]:
        return pulumi.get(self, "client_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetUserPersonalResult(dict):
    def __init__(__self__, *,
                 company_name: Optional[str] = None,
                 country: Optional[str] = None,
                 first_name: Optional[str] = None,
                 last_name: Optional[str] = None,
                 phone_number: Optional[str] = None):
        if company_name is not None:
            pulumi.set(__self__, "company_name", company_name)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="companyName")
    def company_name(self) -> Optional[str]:
        return pulumi.get(self, "company_name")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[str]:
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[str]:
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[str]:
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class GetUserShortProfileResult(dict):
    def __init__(__self__, *,
                 user_name: Optional[str] = None):
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetUsersUserResult(dict):
    def __init__(__self__, *,
                 email: str,
                 logins: Sequence['outputs.GetUsersUserLoginResult'],
                 personals: Sequence['outputs.GetUsersUserPersonalResult'],
                 roles: Sequence[str],
                 short_profiles: Sequence['outputs.GetUsersUserShortProfileResult'],
                 status: str,
                 user_id: str,
                 user_name: str):
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "logins", logins)
        pulumi.set(__self__, "personals", personals)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "short_profiles", short_profiles)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "user_id", user_id)
        pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def email(self) -> str:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def logins(self) -> Sequence['outputs.GetUsersUserLoginResult']:
        return pulumi.get(self, "logins")

    @property
    @pulumi.getter
    def personals(self) -> Sequence['outputs.GetUsersUserPersonalResult']:
        return pulumi.get(self, "personals")

    @property
    @pulumi.getter
    def roles(self) -> Sequence[str]:
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter(name="shortProfiles")
    def short_profiles(self) -> Sequence['outputs.GetUsersUserShortProfileResult']:
        return pulumi.get(self, "short_profiles")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetUsersUserLoginResult(dict):
    def __init__(__self__, *,
                 credentials: Optional[Sequence['outputs.GetUsersUserLoginCredentialResult']] = None,
                 idps: Optional[Sequence['outputs.GetUsersUserLoginIdpResult']] = None):
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if idps is not None:
            pulumi.set(__self__, "idps", idps)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[Sequence['outputs.GetUsersUserLoginCredentialResult']]:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def idps(self) -> Optional[Sequence['outputs.GetUsersUserLoginIdpResult']]:
        return pulumi.get(self, "idps")


@pulumi.output_type
class GetUsersUserLoginCredentialResult(dict):
    def __init__(__self__, *,
                 permissions: Optional[Sequence[str]] = None):
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetUsersUserLoginIdpResult(dict):
    def __init__(__self__, *,
                 client_type: Optional[str] = None,
                 id: Optional[str] = None):
        if client_type is not None:
            pulumi.set(__self__, "client_type", client_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="clientType")
    def client_type(self) -> Optional[str]:
        return pulumi.get(self, "client_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetUsersUserPersonalResult(dict):
    def __init__(__self__, *,
                 company_name: Optional[str] = None,
                 country: Optional[str] = None,
                 first_name: Optional[str] = None,
                 last_name: Optional[str] = None,
                 phone_number: Optional[str] = None):
        if company_name is not None:
            pulumi.set(__self__, "company_name", company_name)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="companyName")
    def company_name(self) -> Optional[str]:
        return pulumi.get(self, "company_name")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[str]:
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[str]:
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[str]:
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class GetUsersUserShortProfileResult(dict):
    def __init__(__self__, *,
                 user_name: Optional[str] = None):
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        return pulumi.get(self, "user_name")


